<h2>Creating plugins</h2>

<p>
	Swiftlet has a modular design. Almost all of it's functionality can be replaced or extended with plugins.
</p>

<p>
	To create a plugin, copy an existing plugin or start with an empty file in the <code>/_app/plugins</code> directory.
	The name of the file will be the name of the plugin and should start with a capital letter (this is a convention for
	file containing a class).
</p>

<h4>Example plugin (<code>/_app/plugins/Example.php</code>)</h4>

<pre>
<?php
if ( !isset($this) ) die('Direct access to this file is not allowed');

class Example_Plugin extends Plugin
{
	public
		$version    = '1.0.0',
		$compatible = array('from' => '1.3.0', 'to' => '1.3.*'),
		$hooks      = array('init' => 1)
		;

	function init()
	{
		$this->ready = TRUE;
	}
}
?>
</pre>

<p>
	This is a very simple plugin that implements the "init" hook (see <a href="../concepts/hook">Hooks</a>). This hook
	is called every time a page loads. The first line of the file is to make sure the plugin isn't being called directly
	from the browser.
</p>

<p>
	The name of the class must
	be the same as the name of the file, suffixed by "_Plugin". Each plugin extends the Plugin class (see
	<a href="../concepts/plugin">Plugins</a>).
</p>

<p>
	The next step is set up a few variables with information about the plugin.
</p>

<ul>
	<li><code>$version</code> (required)</li>
	<li><code>$compatible</code> (required)</li>
	<li><code>$dependencies</code></li>
	<li><code>$hooks</code></li>
</ul>

<h3>Creating database tables</h3>

<p>
	In many cases plugins need access to the database and new tables need to be created. This can be done using the
	<em>install</em> hook. These plugins need to be installed through the plugin installer at <code>/installer/</code>.
	Here is a more elaborate example of a plugin:
</p>

<pre>
<?php
if ( !isset($this-&gt;app) ) die('Direct access to this file is not allowed');

switch ( $hook )
{
	case 'load':
		$info = array(
			'name'         => 'example',
			'description'  => 'Description here.',
			'version'      => '1.0.0',
			'compatible'   => array('from' => '1.2.0', 'to' => '1.2.*'),
			'upgradable'   => array('from' => '1.1.0', 'to' => '1.1.*'),
			'dependencies' => array('db'),
			'hooks'        => array('init' => 1, 'install' => 1)
			);

		break;
	case 'install':
		$this->app->db->sql('
			CREATE TABLE `' . $this-&gt;app->db->prefix . 'example` (
				`id`  INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
				`foo` VARCHAR(256)     NOT NULL,
				PRIMARY KEY (`id`)
				)
			;');

		break;
	case 'upgrade':
		$this->app->db->sql('
			UPDATE `' . $this-&gt;app->db->prefix . 'example` SET
				`foo` = "bar"
			;');

		break;
	case 'init':
		require($controller->classPath . 'example.php');

		$this->app->example = new example($this-&gt;app);

		break;
}
?>
</pre>

<p>
	The <em>install</em> and <em>upgrade</em> hooks are used by the plugin installer.
	Plugins can only be upgraded if the Swiftlet version matches the values in <code>$info['upgradable']</code>
	(to go from version 1.0.x to 3.0.x, you usually have to upgrade to version 2.0.x first).
</p>

<p>
	Because this plugin requires a database, the <em>db</em> plugin should be declared as a dependency. This
	ensures the plugin will not be installed unless the <a href="../plugins/mysql">Database</a> plugin is
	installed and ready.
</p>

<h3>See also</h3>

<ul>
	<li>
		<a href="../concepts/plugin">Plugins</a>
	</li>
</ul>
